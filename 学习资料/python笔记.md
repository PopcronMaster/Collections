# Python笔记

## 数据类型

### 一，number类型

1. 整数（int），包含正整数和负整数
2. 浮点数
3. 复数

#### 运算符：

+，-，*，/，

%(取模，返回余数)，

**(幂)，

//(取整)，

==  等于

!=   不等于 

<, >, <=, >=,

比较运算符返回的是一个布尔值。

=，赋值运算符。

逻辑运算：and，or，not，

##### 位运算（转换成二进制）

&  按位与（对应位置上都为1，则为1）

|   按位或（对应位置上有一个为1，则为1）

^   按位异或（对应位置上，相同为0，不同为1）

~   按位取反(将对应位置上的0变1，1变0)

<< 左移（number * 2**n）

（>>）右移（number//2**n）

##### 成员运算符：

in：判断元素是否在序列中

not in ：判断元素是否不在序列中

##### 身份运算符：

is：判断两个标识符是否引用同一个对象。

is not：判断两个标识符是否引用不同的对象。



#### number中常用函数：

##### 内置函数：

float(num),转换为浮点数

int(num)，转换为整数值

abs(num),返回绝对值

max()，返回最大值

min，返回最小值

pow(a,b),返回a的b次方

round(a,b),返回近似值，保留b位小数，若b不给，默认保留整数。四舍五入，在python3.x中出现n.5默认向偶数靠拢。

##### 格式化输出：

%s :字符串

%d :整数，

%02d:占2位，高位不够补0

%f :浮点数，

%.2f :保留2位小数



##### math模块

math.ceil(a),向上取整

math.floor(a),向下取整

math.modf(a),拆分小数和整数部分

math.sqrt(a),开平方，只返回正值。

##### 随机函数（randm模块)

random.choice([1,2,3,4,5,6,7,8,9]),随机挑选。

radom.randrange函数：randrange(a,b,c),a初始值，不写默认为0，b,为结束值，c,为步长，不写默认为1。

random.random():随机产生0-1的浮点数。

random.shuffle(list):随机排列

random.uniform(m,n):随机产生一个m-n之间的浮点数。







### 二，string字符串类型

##### 字符串的拼接：

1. 用逗号拼接，会产生一个空格
2. 使用+号拼接，要求数据类型必须相同
3. 使用%拼接，格式化输出
4. 使用join函数拼接，'*'.join(iter),用引号里的元素将括号里的元素拼接起来，数据类型必须一样。

##### 字符串的重复输出：

str*n:将str重复输出n次

##### 获取字符串中的字符：

str[n],获取字符串的第n-1个字符。

str[-1],获取最后一个字符

str[start : end : step]:截取字符串部分或全部字符。

##### 判断是否包含指定字符：

##### 字符之间的比较：

实际是ASCII的比较

s (not)   in   str

##### 字符串常用函数：

1. eval(str)：将字符串转为有效的表达式并返回计算结果。
2. len(str)：返回字符串的长度
3. str.lower()：将字符串中所有大写转为小写。
4. str.upper()：小写转大写
5. str.swapcase()：小写转大写，大写转小写。
6. str.capitalize()：第一个大写，其余小写。
7. str.title()：每个单词首字母大写
8. str.center(长度，填充字符)，居中
9. str.ljust(长度，填充字符)，居左
10. str.rjust(长度，填充字符)，居右
11. str.zfill(长度)，前面补0，字符居右
12. '''长字符串'''，三引号，字符串较长时使用，可保留字符串原格式输出。
13. str.count('s',开始，结束),计算指定字符在字符串中出现的次数。
14. str.find('s',开始，结束)，在字符串中从左往右查找字符或子串，返回第一个字符第一次出现的索引位置，若找不到则返回-1，str.rfind(),从右往左查找。
15. str.index(),同find查找，不同的是找不到时会报错，rindex一样。
16. str.lstrip('s'),去掉字符串左边指定字符，不提供参数则去掉空白。
17. str.rstrip('s'),去掉字符串右边指定字符
18. str.strip('s'),去掉字符串两边指定字符
19. str.split('s')：字符切片，不提供参数默认在空格，逗号，换行等处切，可指定字符串和切的次数maxsplit=n，
20. str.splitlines(),按行切，keepends=True,保留换行符，False，不保留。
21. str1.join()

##### 字符串的替换：

1. str1.replace(old,new,count):

   三个参数：旧字符串，新字符串，替换的次数。

2. 字符串映射替换：table = str1.maketrans(old,new):

   old与new的长度要一一对应，对应位置上的字符串替换。

   str2.translate(table)

##### 判断字符串的开头和结尾：

1. str1.startwith(str2,start,end):str1d的某个位置是否以str2开始。
2. str1.endwith(str2,start,end):str1d的某个位置是否以str2结束。

##### 字符串的编码与解码：

编码：str1.encode('utf-8')

解码：str1.decode('utf-8')

##### 判断字符串类型：

1. str1.isalpha():判断是不是全部为字母
2. str1.isalnum:判断是不是为字母或数字
3. str1.isupper():判断是否全部为大写
4. str1.islower():判断是否全部为小写
5. str1.istitle():判断是否全部为首字母大写，其他的小写（标题化）
6. str1.isspace():判断是否全部为空白符
7. str1.isdigit():判断是否全部为数字
8. str1.isnumeric():判断是否全部为阿拉伯数字(也可识别中文)
9. str1.isdecimal():判断是否全部为阿拉伯数字，不识别中文。





### 三，bool布尔值类型

例如：Ture，False

运算时Ture为1，False为0

### 四，None，空值类型

None不等于0

### 五，list列表

一个有序集合

#### 列表的操作

1. 列表的组合：list1 + list2 = list3

2. 列表的重复：list1 * n:列表中的元素重复输出n次，并返回一个新列表。

3. 判断某个元素是否在列表中：元素 in 列表，存在返回True,不存在返回False。

4. 列表的截取：list[开始，停止，步长]

   list[ : : -1]将列表倒叙。

5. 列表的索引：list[index]

6. 列表中添加元素：

   - list.append(元素)，添加在末尾。

   - list.extend(可迭代对象（可放在for in 后面的对象）)，将可迭代对象中的元素去除然后打碎插入。

   - list.insert(index,元素)：插入到指定位置。原本位置上的元素不会被覆盖。

7. 删除元素

   - list.pop(index)，参数默认位-1，删除最后一位元素。提供索引可删除指定位置上的元素，并且返回该元素。
   - list.remove(对象),移除第一个匹配到的元素，无返回值。
   - list.clear(),清空列表。但列表还存在。
   - del list，直接删除整个列表。
   - del list[index] 删除指定元素

8. 统计元素在列表中出现的次数：list.count(元素)

9. 获取列表中元素的个数：len(list)

10. 获取列表中的最大元素：max(list)

11. 获取列表中的最小元素：min(list)

12. 列表倒叙：list.reverse()，不返回新列表。

13. 排序列表：list.sort(),可传递参数reverse=Ture,False,来实现倒叙或升序。list.reverse()倒序

14. 列表拷贝

- 赋值拷贝：list1 = list2

  ![1550820840750](C:\Users\王碧波\AppData\Local\Temp\1550820840750.png)

- 浅拷贝：list2 = list1.copy(),这种方式仅限于**一维列表**，有开辟一块新的内存空间，由于二维列表在一维列表中存的是地址，所以改动二维列表会改变拷贝的列表。

- 深拷贝，需导入copy模块，list2 = copy.deepcopy(list1),将list1中所有元素拷贝，不会出现操作同一内存的情况.

15. 枚举函数，list1.enumerate(对象，开始位置),返回索引位置和对应的值。

### 六，tuple元组

一个有序集合，一旦初始化就无法更改

##### 创建方式

1. t = ()
2. t = (1,)
3. t = 1,
4. t = 1,2
5. t = tuple()

##### 元素的访问：

	tuple(index)

##### 修改元组：

	存储在元组中的元素其实是存储的地址，可以通过修改元组里列表里的元素来修改元组。

##### 元组的删除：

	del tuple

##### 元组的操作：

1. 元组的拼接：tuple1 +  tuple2 =tuple3
2. 重复输出：tuple1 *n
3. 判断元素是否在元组中：in tuple
4. 元组的截取：tuple[start : end :step]
5. 获取元组长度：len(tuple)
6. 获取元组最大值，最小值max,min
7. 将列表转为元组：tuple(list)
8. 二维元组：tuple = (tuple1,tuple2)
9. 元组的遍历：for x in tuple:

### 七，dict字典

一个无序的集合，以键-值对方式储存，key-value。

##### key特性：

1. key必须是唯一的。
2. key必须是不可变的。

##### 访问元素：

- dict1[key] ,不存在的时候会报错
- dict1.get(key)，不存在的时候返回None

##### 添加元素：

- dict1[key] = value,多次对一个key赋值会覆盖前面的key。

##### 删除元素：

- dict1.pop(key):会返回对应的value，若不存在会报错。
- dict1.clear():清空
- del dict1[key]:删除元素

##### 遍历字典：

- for x in dict1:遍历key
- for x in dict1.values():遍历value
- for k,v in dict1.items():遍历key和value。

##### 字典与列表区别：

- 都是集合，都是可变类型的
- 字典是无序的，列表是有序的
- 列表比字典节约空间
- 当数据量增大的时候，列表的查询速度会因为数据量的增大而明显变慢，而对于字典变化不大。

### 八，set集合

1. 只存储字典中的key值。set中的值不重复（去重功能）。

2. set集合中的值不可变。（不可储存list，dict，set）

3. set是个无序集合

4. 创建set:  set1 = set()

   set1 = {1,2,3}

   set1 = set([1,2,3,4,5])

##### set操作：

添加元素：

- set1.add(),无返回值，必须添加不可变类型，不存在二维set

- set1.update(iter): 必须是可迭代对象，不可是二维的列表，字典

删除元素：

- set1.remove(元素)，无返回值

遍历元素：

- for x in set1:

交集和并集：

- 并集：set1 & set2
- 交集：set1 | set2

### 九，变量

1. type() ，查看变量的类型
2. id()，查看变量的地址
3. del()，删除变量

### 可迭代对象：

list, tuple, dict, set, str, 生成器，

##### 列表生成式：

[结果   for x in rang()   语句]

若将[]改成()，那么这么列表生成式就变成了生成器。

##### 生成器：

可以一边循环一边计算的机制，是一个典型的迭代器。优点可节约内存空间。遍历的时候只能循环一次。

##### 迭代器：

不但作用于for循环，还能被next函数调用。

本质：内部复写了____next___,_________iter___函数

##### 可迭代对象转换为迭代器：

iterator = iter(iterable)

## 函数

##### 优点：

- 简化代码结构，增强代码的复用性
- 增强代码的可维护性

##### 语法：

- def 函数名(参数列表):

  	函数体

  	return 表达式【可不写，默认为None】

##### return：

- 返回值
- 结束函数

### 参数：

	在函数运算过程中，涉及到的一些未知量，可以设置为参数。

#### 传参：

- 本质：是一个赋值的过程

- 值传递：不可变类型参数的传递
- 引用传递：传递的是可变类型

####  形参：

	定义在函数参数列表中的，用于接收参数值的

#### 实参：

	函数调用过程中，传递的参数，给形参赋值的

#### 位置参数（必选参数）：

	传参的时候，传递的顺序是不可变的，当位置参数与关键字参数同时存在的时候，需要将位置参数写在关键字参数的前面。

#### 关键字传参：

- 数据更加清晰
- 可以忽略位置关系

#### 默认参数：

	定义函数时，可以给参数设置一个默认值，调用函数的时候可以传递该参数，也可以不传。当必选参数与默认参数同时存在的时候，要将默认参数写在后面。**默认参数必须时不可变的对象**。

#### 不定长参数：

	在函数定义过程中，有时候不确定用户会传递多少个参数进来，这时候就可以使用不定长参数。

##### 包裹位置参数：

	*args，与位置参数相比多了一个星号，能收集除位置参数之外所有剩余的位置参数。收集到的参数作为**元组**来处理。

##### 包裹关键字参数

	**kwargs，收集到的参数作为字典处理，传递的变量名作为key，传递的值作为value。

#### 顺序：

	位置参数，默认参数，包裹位置参数，包裹关键字参数。

### 匿名函数：

lambda 参数列表：表达式

匿名函数的调用：将匿名函数赋值给一个变量，传入参数即可。

### 生成器函数：

```python
def func(n):#函数内部有yield就是一个生成器函数
    print(n)
    yield n
    print(n+1)
    yield n+1
func1 = func(10)#不会执行函数内部代码
print(next(func1))#执行到第一个yield暂停，并返回yield的值。
```



### 装饰器：

##### 概念：

	在代码运行期间，可以动态的给代码增加功能的方式。

##### 语句：

```python
def outer(f):
	def inner():
		print('*********')
		return f()
	return inner

@outer
def func():
    print('2019-2-27')
```

	函数中嵌套了一个函数，外面的称为外函数，里面的称为内函数，外函数参数必须是被装饰的函数名，在内函数中需要执行被装饰的函数，外函数返回时，需要将内函数的引用函数名返回。

##### 注意：

- 外函数的参数是被装饰的函数
- 在内函数中一定要执行被装饰的函数
- 外函数的返回值一定要是内函数的函数名

### 偏函数:

```python
functools.partial(要固定的函数，要固定的参数)
```

### 变量的作用域：

	指的是变量的使用范围

##### 局部作用域L（local）：

	定义在def关键字中的，也就是在函数体中定义的变量，它只作用与当前函数，当函数执行结束之后，这个函数占用的内存就会被回收。

##### 嵌套作用域E（enclosing)：

	在嵌套函数中外函数中的作用域

##### 全局作用域G（global）：

	在全局作用域中定义的变量，是定义在.py文件内，函数体之外的变量。在整个.py文件中都能使用。

##### 内置作用域B（built-in）：

	系统内部固定的变量。在整个python项目中都能使用。

#### 变量名的解析法则：

	LEGB法则：搜索优先级：局部>嵌套>全局>内置

##### global关键字：

	若要在函数体内更改全局变量的时候，可用global关键字声明此变量为全局变量，再进行更改。

##### 注意：

	在python中只有模块，类，函数才会产生新的作用域。而if/else，try/except，while，for，这些语句块不会产生新的作用域。

### 回调函数：

	把函数当作参数传递到另一个函数中，当这个函数在传递的函数中被调用的时候，称这个函数为回调函数。

### 返回函数：

	当函数当作为返回值返回的时候，称为返回函数。

### 闭包：

	**概念**：在外函数中定义了一个内函数，内函数使用了外函数的临时变量，而外函数的返回值是内函数的引用【内函数的函数名】，这样就构成了一个闭包。装饰器一定是闭包，但闭包不一定是装饰器。
	
	**特点**：一般情况下，当函数执行结束后，函数中定义的临时变量都会销毁，但是在闭包存在一种特殊情况，外函数执行结束之后，发现自己的临时变量在内函数中还需要使用，这时候外函数会将自己的临时变量绑定给内函数，然后再自己结束。
	
	**作用**：提高函数复用率；减少函数名的冲突以及变量的定义。

### 递归函数：

	在函数内部调用自己本身这个函数，称为递归函数。

解决问题思路：

1. 找到临界条件
2. 找到这次与上次的关系
3. 假设这次的结果已经知道，如何求出上次的结果。

##### 特点：

- 定义简单
- 逻辑清晰
- 速度较慢
- 递归层数有限制，层数过多会造成栈溢出，

### os模块：

	操作文件。以及文件路径

##### 常用操作：

1. os.getcwd()，获取当前文件所在目录的绝对路径

   - 绝对路径：windows中以磁盘开头C:,E:,D:等以\\\开头的，

     mac中以/开头的

   - 相对路径：以.或者..开头的文件

2. os.listdir(path)，列举目录下所有文件，以列表的方式返回，只返回文件名。若没指定path，则列举当前目录文件下所有文件。路径不存在的时候会报错。

3. os.path.abspath()，返回指定路径的绝对路径

4. os.path.split()，将文件路径分割成文件夹与文件名，以元组的方式返回。本质是以path最后一个'\\'进行分割，只分割一次。

5. os.path.join(path,‘path1’，‘path2’。。。)，对指定的路径进行拼接，返回拼接结果，当path中出现绝对路径的时候会删除之前的路径，只返回绝地路径。

6. os.path.dirname()，只返回目录的部分

7. os.path.basename()，只返回文件部分，即文件名。

8. os.path.getsize(path)，获取文件大小，以字节为单位，获取不了文件夹大小。不存在是会报错。

9. os.path.exists(path)，判断文件是否存在，存在返回Ture,否则返回False.

10. os.path.isdir(path)，判断指定路径是否为目录。

11. os.path.isfile(path)，判断指定路径是否为文件。

### 栈与队列：

#### 栈：

深度遍历

在python中没有栈，用列表来模仿栈结构。

```python
mystack = []
mystack = append(1)
mystack = append(2)
mystack = append(3)
mystack = append(4)
mystack = append(5)

mystack.pop()
mystack.pop()
mystack.pop()
mystack.pop()
mystack.pop()
```



##### 特点:

- 先进后出，后来居上。

#### 队列：

广度遍历

生成队列：collections.deque()

```python
import collections
queue = colletions.deque()
queue.append(1)
queue.append(2)
queue.append(3)
queue.append(4)
queue.append(5)

queue.popleft(1)
queue.popleft(2)
queue.popleft(3)
queue.popleft(4)
queue.popleft(5)
```

##### 特点：

- 先进先出

## 模块

定义：

	在python中一个.py文件就是一个模块。

#### 模块划分：

	按照功能划分，相同或者相似的放在一个模块中。

#### 优点：

- 提高代码的可维护性
- 提高代码的复用性
- 可以引入其他模块
- 可以避免函数名与变量名冲突

#### 自定义模块的引用：

1.  引入：import  模块1，模块2。。。
2. 调用：模块名.函数名(参数)，变量也可用此方法调用
3. 局部引用：from  模块名   import   函数名1 ，函数名2。。。，调用的时候直接使用，可能会引起函数名或变量名冲突。
4. 整体引用，from   模块名   import   *，导入模块所有函数和变量，调用的时候不需要加模块.，很可能会引起变量名和函数名冲突。

#### name属性：

	当该模块被其他模块引入的时候，该模块中执行的函数需要进行隔离，这时候就需要执行____name____属性。每个模块中都有一个内置变量，当该模块在自身执行的时候，____name____的值为该模块的模块名，因此可以通过____name____的值来进行区分文件是否在该模块中执行。一般大型项目中，通常都会使用if ____name____ == '____main___':，作为正常程序的入口。

#### 包：

	为了解决不同开发人员在开发同一个项目的时候，发生模块重名的情况，在模块外部套一层目录，这个目录就叫包，为了区别与普通的目录，这时候包中会创建一个____init____.py的文件，只要最外面的包名不发生冲突，这个模块就不会冲突。

#### sys模块：

1. sys.path()，返回python内建规则查找的一个列表
2. sys.platform()，获取当前执行环境的平台信息
3. sys.argv()，可以从外部往内部传递参数。argv[0]是当前文件的绝对路径。

#### time模块：

##### 时间戳：

从1970年1月1日到现在，单位s

UTC：格林尼治时间，世界标准时间，中国时间为UTC+8

DST：夏令时

##### 常用操作：

- time.time()，获取当前时间的时间戳
- time.gmtime(sec)：将时间戳转换为格林尼治时间元组
- time.localtime(sec)：将时间戳转换为当前时间元组
- time.asctime(lt)：将时间元组转换为字符串
- time.ctime(time)：将时间戳转换为字符串
- time.strftime(‘%Y-%m-%d %H:%M:%S',lt)：将时间元组格式化为时间字符串。
- time.mktime(strpt)：将时间元组转换为时间戳。
- time.sleep()：让cup休眠X秒
- time.clock()：一般成对出现，用来计算CPU的用时。模块中的第一个clock用来标记，第二个clock会返回从标记开始到第二个之间的CPU用时。第三个仍然是以第一个开始计算。

#### datetime模块：

- datetime.datetime.now()：获取当前时间,返回一个datetime对象
- 两个datetime对象相减会返回一个时间差对象
- dtime.days，获取间隔的天数
- dtime.seconds，获取间隔的秒数
- datetime.strftime(format)，将datetime对象格式化为字符串

#### calendar模块：

- calendar.month(year,month):返回指定年月的日历
- calendar.calendar(year):返回指定的日历
- calendar.isleap(year)：判断指定年份是否为闰年
- calendar.leapdays(year1,year2)：返回这期间有几个闰年
- calendar.monthrange(year,month)：返回某年某月从周几开始，一共多少天。
- calendar.monthcalendar(year,month)：返回某年某月以星期为单位的一个序列，若不是本月日期，用0代替。
- calendar.weekday(year,month,day)：返回指定日期的星期码

## 面向对象：

	基于万物皆对象的哲学思想

### 与面向过程的联系与区别：

- 都是看待问题的思路
- 面向对象着眼与找到一个具有特殊功能的对象，能够解决你需要解决的问题；面向过程着眼于细节，以及解决问题的思路。

### 核心：

类与对象

#### 类：

	一个具有特殊功能的实体集合

#### 对象：

	一个具有特殊功能的能够解决问题的实体，也称为实例。

##### 关系：

	类是对象的抽象，对象是类的具体体现。

##### 注意：

	类属于一个数据类型，类似与str,list,dict...类本身不占内存，但实例会占内存。
	
	类名后的小括号可以省略。

```python
class Person:
	pass

class Person1():
	pass

class Person3(object):
    pass
```

以上三种写法意义相同

##### 命名：

	遵循“驼峰式命名法”，【大驼峰】每个单词首字母都大写，一般用于被类命名；【小驼峰命名发】第一个单词首字母大写，其他小写，一般用于变量或者函数。一定要做到见名知意。

### 类设计：

1. 类名：人类
2. 特征：身高，体重，性别【名词】
3. 行为：吃饭，运动，睡觉【动词】

#### 在类中定义方法和属性：

1. 定义类名
2. 特征------->属性
3. 行为------->方法/函数

##### 类方法：

	绑定在类身上的，专门为类准备的方法。可以使用对象来调用，但是建议使用类名来调用。
	
	当写在类里的函数。跟self没关系【没有使用成员变量，也没使用成员方法】，跟类变量，类方法有关系【在此函数中，可能使用了类变量或者类方法】，这时候就可以使用类方法。

##### 静态方法：

	写在类中的普通方法,使用@staticmethod来进行装饰，可以使用类名来调用。也可以使用对象名调用。推荐使用类名。
	
	写在类中的函数，既跟self没关系，也跟类没关系，就写成静态方法。

```python
class Music:
    @classmethod
    def getNext(cls):#类方法
        cls.index += 1
        print('下一曲为',cls.inde)
    def __init__(self):#成员方法
        pass
    
    @staticmethod
    def welcome():#静态方法，无需传入self
    	print('欢迎')
```



##### 成员方法：

	在class内部定义的函数，称为成员方法，成员方法的第一个参数是self，表示对象本身，不需要传递参数。绑定在对象身上的。不能使用类名来调用。
	
	写在类中的函数，跟self有关系的时候【使用了成员变量，或成员方法】，这时候必须使用成员方法。

##### 总结：

- 成员方法的隐含参数为self，类方法的隐含参数为cls，静态方法没有隐含参数。
- 成员方法，静态方法，类方法都可以使用对象进行调用，成员方法不能使用类名来调用。
- 静态方法和类方法虽然可以使用对象调用，但不建议使用，因为静态方法和类方法专门给类准备的。

### 类的调用：

对象名 = 类名（）

对象名.属性

对象名.方法名

### 构造函数/构造方法/构造器：

	____init____(self):这个函数不需要手动调用，当我们创建对象的时候会自动的调用此方法。

### 析构函数：

	__del__(self):释放对象的时候自动调用

### 成员变量与类变量：

#### 成员变量：

	定义在函数中，且绑定在self身上的变量。使用对象来调用。

##### 使用情况：

	在创建对象的时候，需要初始化的变量，使用成员变量。

#### 类变量：

	在类中，且在函数体外定义的变量，也称为静态变量。使用类名来调用。

##### 使用情况：

	普通变量定义在了类中，一些静态这种变量可以使用类变量

##### 区别：

	当类变量与成员变量同时存在的时候，使用对象来调用，优先查找成员变量，若不存在再查找类变量。

##### 注意：

	若要更改类变量，使用类名+变量名来改

#### 动态的给类添加属性和方法：

	动态的给对象绑定属性和方法，只作用于当前对象，对其他对象不起作用。动态的给类添加属性和方法对所有对象起作用。

##### ——slots——函数：

	有时候，不想随意给对象添加一些属性，可以使用——slots——属性，这个属性是一个元组，可以将要添加的属性一一写在这个元组里。只对当前类起作用，对子类不起作用。

### 封装：

#### 广义的封装：

	函数，模块，类

#### 狭义的封装：

	变量私有化的过程
	
	在变量前面加__，
	
	@property，这个装饰器可以将一个方法变成属性来调用。
	
	@property本身又创建了另一个装饰器，@属性.setter，负责把一个setter方法变成属性赋值。
	
	使用此装饰器可以使调用更加简单，而且还可以添加一些必要的数据过滤。

##### 黑魔法：

	被私有化的属性不能被访问的原因是python解释器解释私有化的属性的时候解释成：_类名__属性名，当我们直接访问的时候就会出错，但通过解释器解释成的名字可以访问，但强烈不建议这么做，因为不同的解释器可能解释出来的变量名可能不同。

##### 下划线：

- 前后双下划线：一般是系统定义的函数或者变量
- 首双下划线：代表私有化，不能直接访问
- 首单下划线：代表保护类型，虽然可以直接访问，但是请视为私有变量，不要直接访问。

### 继承：

	如果两个或两个以上具有一些相同的属性或者方法，可以将相同的属性或方法抽取出来，这个被抽取出来的类叫做父类/超类/基类，其他的称为子类/派生类，他们之间的关系就是继承。若一个类没有继承任何类，默认情况下它继承的是object类，object类是一切类的基类。
	
	子类可以继承父类中除了被私有化的所有的属性和方法。
	
	父类不能访问子类中的属性或方法

##### 优点：

- 提高代码的可维护性
- 提高代码的复用性
- 提高代码的安全性

##### 缺点：

- 增加代码的耦合度

##### 注意：

	当子类中有特殊属性的时候，需要手动调用父类中的构造方法，在子类中声明变量的时候，无论是继承的属性还是自己特有的属性，都需手动声明。

super().——_init_——()

#### 多继承：

1. 若同时继承多个父类的时候，需要手动初始化父类构造函数
2. 当父类中的函数名出现相同的时候，优先选择写在继承元组前面的那个。
3. 一个子类可以继承多个父类，一个父类也可以有多个子类。

### 多态：

	一种事物具有多种表现形态【在python中并不存在真正意义上的多态，因为python是一门动态类型的语言，传入的是什么类型，接收的就是什么类型。

python鸭子模型优点：

- 增加代码的灵活性
- 不关注数据类型，关注使用方法          

## 文件：

### 读写文件：

	python中提供了内置的方法可以进行文件的读写，当我们读写文件的时候，并不是直接操作磁盘，因为现在所有的操作系统都不允许普通程序直接操作磁盘，我们是向操作系统发出文件读写请求，通过操作系统预留的API接口来进行操作。

#### 读取：

```python
f = open(path,'r',encoding,errors)
path:文件路径
encoding：指定文件的编码格式
errors='ignore'忽略编码错误
'r'--读取
'w'--写入，若文件不存在则创建文件，若存在则会覆盖之前文件。
'x'--
'a'--追加，若文件不存在则创建文件，若存在则添加在原文件后面。
f.read()，一次性读取所有内容
f.read(size)，读取size字节大的文件。【文件较大时使用】
f.readlines()，读取所有行，返回列表。【读取配置文件时使用】
f.close()，关闭
f.readline()，一次读取一行。
```

	当文件读写完毕之后，必须要用close方法关闭，因为打开的文件是占用系统资源的，并且系统同一时间打开的文件的个数是有限制的。
	
	系统封装的读写文件语句：

```python
with open(path,'x',encoding='utf-8') as f
	f1 = f.read()
    f2 = f.write()
```

	二进制文件的读取：

```python
#读取
with open(path,'rb') as f
	f.read()
#写入
with open(path,'wb') as f
	f.write(b'')
```

#### 在内存中读写：

使用io模块中的StringIO

##### 读写二进制：

BytesIO

```python
from io import StringIO/BytesIO
bio = BytesIO
sio = StringIO
sio.read('')
sio.write('')
```

### 序列化：

把变量从内存中变成可储存或者传输的过程

#### 反序列化：

将序列化的对象重新读到内存的过程

#### json模块：

```python
import json
dict1 = {'name':'lili', 'age':23}
res = json.dumps(dict1)
key必须使用双引号

```

**json.dumps(obj)**:可将基本数据类型序列化为字符串，若是自定义的数据类型，要添加一个default的参数，后面跟的是将对象转换为字典的函数的函数名。

**json.loads(f.read())**：可将字符串反序列化为基本数据类型，若是自定义的数据类型，需要添加obj_hook参数，将字典转换为对象的方法。

#### csv文件：

```python
import csv
with open(path,'r') as f:
    res = csv.resder(f)
    for line in res:
        print(line)
```

### 错误处理：

```python
try:
    有可能发生错误的代码块
except 错误:
    错误处理
finally:
    无论是否发生错误，都会执行的代码块
```

#### 记录错误：

##### logging：

logging.exception(错误)

#### 抛出错误：

raise 错误

## 高阶函数：

##### map函数：

```python
map(func,iter)
func只能有一个参数
将可迭代对象iter中的每一个元素一一作用于func，并将作用后的结果作为一个迭代器返回
```

##### reduce函数：

```python
from functools import reduce
reduce(func,iter)
func:只能有2个参数
iter：被作用的序列
功能：一次将序列中的元素作用于函数，并返回结果
```

##### filter函数：

```python
filter(func,list1)
把传入的函数依次作用于序列中的每一个元素，根据返回的True或者False决定是否保留该元素。
该函数返回的是一个迭代器
注意：原序列不会改变！！！
```

##### sorted函数：

```python
作用：实现对列表的排序。
iterable：是可迭代类型;
cmp：用于比较的函数，比较什么由key决定;
key：用列表元素的某个属性或函数进行作为关键字，有默认值，迭代集合中的一项;
reverse：排序规则. reverse = True  降序 或者 reverse = False 升序，有默认值。
返回值：是一个经过排序的可迭代类型，与iterable一样。
```

##### zip函数：

```python
zip() 函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。
如果各个可迭代对象的元素个数不一致，则返回的对象长度与最短的可迭代对象相同。
利用 * 号操作符，与zip相反，进行解压。
zip``(iterable1,iterable2, ...)
`
```

### 测试：

> 分类：黑盒测试，白盒测试，灰盒测试

##### 单员测试：

	单元测试就是用来对一个模块、一个函数或者一个类来进行正确性的检测工作。

##### 文档测试：

	文档测试的作用：可以提取注释找那个的代码执行
	
	doctest模块可以提取注释中的代码执行
	
	doctest严格按照python的交互模式的输入进行提取
## 正则表达式：

regular expression：匹配指定规则的字符串

### 排列：

```python
import itertools
res = itertools.permutations([1,2,3,4],3)

```

### 组合：

```python
import itertools
res = itertools.combinations([1,2,3,4],3)
```

#### 笛卡儿积：

```python
import itertools
res = itertools.product([1,2,3,4],3)
```

#### 使用方法：

- re.match()：类似与startwith，开头匹配，区分大小写，找不到返回None

> flags：re.I：忽略大小写
>
> re.S：和符号.搭配使用，让.可以匹配带换行符\n
>
> re.M：换行模式

- re.search：是否包含正则表达式所匹配的内容，只找到第一个匹配的。找不到返回None。

- re.findall：获取所有匹配的内容。找不到返回空列表。

#### 正则表达式符号：

##### 单个字符：

-    .   ：表示任意单个字符，除了换行。使用re.S就可以匹配到。如果.就是点，要用\转义
-    |：或，a|b-----取a或b
-    []  ：单个字符的范围
  - [abc]：匹配a,b或者c
  - [a-z]：匹配a-z范围之间的单个字符
  - [a-zA-z0-9]：匹配字母和数字
  - [a-zA-z0-9_]：匹配字母和数字和下划线
-    \d ：表示数字，相当于[0-9]
-    \D ：表示非数字，相当于[^0-9]
-    \w ：表示数字字母下划线，相当于[a-zA-z0-9_]
-    \W ：表示非数字字母下划线
-    \s ：表示空格，换行\n，制表符\t，回车符\r，换页符\f。
-    \S ：非\s
-    \A：跟^类似，区别：换行模式下，下一行不会重新进行正则匹配。
-    \Z：跟$类似，区别：换行模式下，下一行不会重新进行正则匹配
-    \Apattern\Z：完全匹配，区别：换行模式下，下一行不会重新进行正则匹配

##### 边界字符：

- ^ ：写在正则表达式前面，开头匹配，相当于match
- $ ：写在正则表达式结尾，结尾匹配，
- ^pattern$：完全匹配，必须和正则内容一致，不能有多余的。
- \b：单词是否以某个字符串结尾
- \B：单词是否不以某个字符串结尾

##### 多个字符：

- *：表示前面字符出现任意多次

- +：表示前面字符出现的次数是1次或多次

- ？：表示前面字符出现0次或1次

- {}：次数范围

  - {3}：出现3次
  - {3,}：出现至少3次
  - {,3}：出现最多3次
  - {3,5}：出现3-5次

  > 贪婪模式：*，+，{}
  >
  > 非贪婪模式：？

##### 获取分组：

```python
res = re.search(pattern,string)
res.group()
res.group(0)
res.group(1)获取第一个分组
res.groups()获取所有字符
```

##### 分组别名：

```python
string = '0755-8888888'
pattern = '(?P<CityCode>\d{4})-(?P<phone>\d{8})'
res = re.search(pattern,string)
?P<别名>：固定格式
调用：res.group('CityCode')
res.group(1)
```

##### 正则拆分：

re.split(正则，字符串)

##### 正则替换：

re.sub(正则，要替换的，被替换的字符串)

##### 正则编译：

com = re.compile(正则)

com.search(字符串)





### pip第三方包管理：

- pip install 包名--->安装第三方包
- pip uninstall 包名--->卸载第三方包
- pip freeze---->显示自己安装的包
- pip list---显示所有包
- pip -V ----查看版本
- pip  show   包名----查看包详情

## 进程，线程：

### 概念：

- **进程**：操作系统分配的一个资源单位
- **线程**：进程的分支
- **多线程**：多个线程并发执行的一种技术，python中多线程是假的
- **协程**：线程的分支
- **GIL**：全局解析器锁，只允许一个线程通过，保证完整性，一致性
- **同步**：按顺序执行代码，在同一个线程或进程中执行
- **异步**：不按照顺序，并行执行，在不同的线程或进程中执行。
- **并行**：类似于异步，任务数量 <= CPU数量
- **串行**：类似于同步
- **并发**：任务数量 > CPU数量
- **守护线程**：随着主线程的结束而结束
- **计算密集型**：计算量较大，消耗CPU资源较大，最好使用C语言编写。
- **I/O密集型**：涉及到网络，磁盘的任务，消耗CPU较少，脚本语言首选，例如python。

### 线程的属性：

- t.name:线程的名称
- threadind.current_thread().name:当前线程的名称
- t.daemon:是否守护线程，默认是非守护
- t.ident:线程id
- t.is_alive:线程是否正在执行
- threading.active_count:正在运行的线程数量
- threading.enumerate:列举当前正在运行的所有线程

### 线程冲突&线程锁：

**线程冲突**：多个线程并发访问同一个变量而互相干扰

**解决线程冲突**：使用线程锁，threading.Lock()

**线程锁**：解决多个线程访问同一个资源的问题

**线程死锁**：互相锁住对方线程需要的资源

**递归锁**：解决线程死锁，threading.RLock()

### 信号量：

**threading.Semaphore(n)**:控制线程最大的并发数

### 协程：

**概念**：又称微线程，协程其实可以认为是比线程更小的执行单元。为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机，我们可以把一个协程切换到另一个协程,只要这个过程中保存或恢复CPU上下文那么程序还是可以运行的。

### 多进程：

**概念**：程序的一次执行过程，负责执行的是CPU。

