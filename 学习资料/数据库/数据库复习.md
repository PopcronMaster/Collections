## 数据库复习

DBMS:数据库管理系统



##### SQL分类：

1. DDL:【Data Definition Language】数据定义语言，创建、修改、删除表结构。
2. DML:【Data Manipulation Language】数据操作语言，用于对数据表进行增删改的操作
3. DQL:【Data Query Language】,数据查询语言，用于负责数据表的查询工作
4. DCL:【Data Control Language】，数据控制语言，用来定义访问权限和安全



##### 数据库操作(DDL):

```
# 创建数据库
create database name charset=utf8mb4

# 创建表
create table name{
    字段1 字段类型 [列级别约束][默认值]，
    字段2 字段类型 [约束][默认值]，
    字段n 字段类型 [约束][默认值]
    [表级别约束,主键等]
}

# 其它命令
show databases
use 数据库名
select database();  查看当前使用的数据库
show tables;
desc table_name;   # 查看表结构
drop database 数据库名

# 修改表名
alter table old_table_name rename [to]  new_name
# 修改字段的数据类型
alter table table_name modify 字段名 数据类型
# 修改字段名
alter table table_name change 旧字段名 新字段名 数据类型
# 添加字段
alter table table_name add 新字段名 数据类型 [约束条件] [first|after 已经存在的字段名(用于新字段的位置)]
# 删除字段
alter table table_name drop 字段名
# 修改字段的排列位置
alter table table_name modify 字段1数据类型 first|after 字段2
# 删除表的外键约束
alter table table_name drop foreign key 外键约束名
# 删除数据表
drop table [if exists] 表1，表2， 表3...
# 删除被其它关联的表
直接删除会出现错误,操作：先解除关联，再进行删除
```



##### 数据操作(DML):

```
# 单/多行数据插入
insert into table_name (字段1，字段2，字段3...) values(值1，值2，值3...),(值1，值2，值3...)...;
字段和值的位置必须对应，且不能违反约定

# update数据更新
update table_name set 字段名=新值, 字段名=新值 [where 条件]

# 数据删除delete
delete from table_name [where 条件]
如果没有指定条件会删除整个表中的数据，清空表也可以使用truncate table 表名;
```



##### DQL，数据库查询

```
# 全表查询
select * from 表名 [条件]
# 指定字段查询
select 字段1，字段2... from 表名 [条件];

# 条件查询
主要结合 where 使用：
between ... and ...
and
or
in
not in
is 
is not

# 模糊查询
like
通配符： - 匹配任意一个字符， % 匹配0~n个字符【n大于等于1】

# 其它：
select 字段 as 取别名
select age+ifnull(id,0) from student; 将null转化

# 排序asc, desc：
select * from student order by age asc;

# 多个排序
select * from student order by age desc,id asc;

# 聚合函数
聚合函数主要用来做纵向运算
select count(*) from student where age > 20;
select sum(*),sum(age) from student;
select max(id),min(age) from student;
select avg(age) from student;
总结： select 聚合函数 from where order by;

# 分组查询
group by：分组查询
having: 有...表示条件,和where类似，只是用在分组后面
select deptno,count(*) from emp group by deptno;
select deptno,count(*) from emp where sal>1500 group by deptno;
select deptno,sum(sal) from emp group by deptno having sum(sal) > 7000;
总结：
having 是在分组之后对数据进行过滤，where是在分组之前对数据进行过滤
having 后面可以使用聚合函数,where后面不可以使用聚合函数
select deptno,sum(sal) from emp where sal > 1500 group by deptno having sum(sal) > 6000;

# 分页查询
limit: 用来限定查询的起始行，以及总行数
select * from emp limit 0,4;

# 总结
查询语句书写顺序：select -> from -> where -> group by -> having -> order by -> limit
查询语句执行顺序: from -> where -> group by -> having -> select -> order by -> limit
```

##### 数据完整性

```
作用：保证用户输入的数据保存到数据库中是正确的
实质：创建键表的时候给表的字段添加约束
约束类型：
	主键约束：primary key
	唯一约束：unique
	自动增长列：auto_increment
	
	非空：not null
	默认值：default
	外键约束：foreign key
	
外键创建:
	create table scorel(score int, couseid int, stuid varchar(10), constraint stu_sco_id foreign key(stuid) references student(stuid))
	alter table score2 add constraint stu_sco_id foreign key(stuid) references student(stuid)
```

##### 表之间关系

```
一对一、一对多、多对多
# 合并结果集
select * from A union select * from B;  # 并集，会去除重复记录
union all : 会拼接所有结果

# 连接查询,会产生笛卡尔积，t1 * t2
select * from student s,score c where s.stuid=c.stuid;

# 内连接 ，查询结果必须满足条件
select s.stuid, s.stuname, c.score,c.coureid from student s join score c on s.stuid = c.stuid
# 外连接 outer join on,以其中一个表作为参照连接 另外一个表
# left join on , right join on
select * from student s left join score c on s.stuid=c.stuid
```

##### 子查询

```
在一个select语句中包含另外一个完整的select语句【select语句的嵌套】
select * from emp where deptno=(select deptno from emp where enname='scott);
```

##### 数据库备份

```
# 导出
mysqldump -u root -p 数据库名 > 生成sql脚本的路径
# 导入
create database test;
source /home/rock/Desktop/mydb1.sql;
```

##### 索引

```
# 索引分类
普通索引、唯一索引、主键索引、全文索引
# 查看表索引结构
show index from 表名;

# 创建普通索引
alter table 表 add index(字段)

# 唯一索引
alter table 表 add unique(字段)

# 主键索引
alter table 表 add primary key(字段)

# 创建表时声明索引
primary key(字段)
index(字段)
fulltext(字段)
unique(字段)
create table usr(
	id int auto_increment,
	name varchar(20),
	primary key(id),
	unique (name)
)engine=innodb default charset=utf8;

# 删除索引
alter table 表名 drop index 索引名;
```

##### 事务

```
事务四大特征：
原子性、一致性、隔离性、持久性

事务流程：
start transaction
update/delete/insert
commit
rollback
```

##### python 连接MySQL

```
import pymsql
# 创建连接
conn = pymysql.connect('localhost','root','root','mydb')

# 创建游标
cursor = conn.cursor()
# SQL语句
sql = 'select * from mytable'
# 执行语句
cursor.execute(sql)
res = cursor.fetmany(3)  # fetchall(),fetchone()
for row in res:
	print(row)
print(cursor.rowcount)
cursor.close()
conn.close()


# 修改数据,使用事务
sql = 'insert into person(name,age) values('aa',20)'
try:
	cursor.execute(sql)
	conn.commit()
except:
	conn.rollback()
cursor.close()
conn.close()
```



### Redis

##### 概述

```
Redis 将其数据库完全保存在内存中,仅使用磁盘进行持久化
```

##### 安装

```
sudo apt-get install redis-server
```

##### 常用命令

```
del key  删除key
exists key 检查
expire key seconds 设置过期时间
pexpire key milliseconds 设置 Key的过期时间以毫秒记
move key db 将当前数据库的key 移动到指定的数据库
persist key 移除key 的过期时间
pttl key 以毫秒为单返回key的过期时间
ttl key  以秒为单位
randomkey 从当前数据库随机返回一个key
rename key newkey 修改key的名称
type key  返回key所存储的值得类型
```

##### 数据类型

```
共五种数据类型
1.字符串,是二进制安全的，即可以存储任何数据、比如数字，图片，序列化对象,常用命令:
set key value  设置键值
get key 取出键值
del key 删除
setex key seconds value  使用键和到期时间设置值
mset key value key value  多个键值一起设置

2.哈希（Hashes），是键值对集合。Redis哈希是字符串字段和字符串值之间的映射，因此它们用于存储对象。
hset ukey name 'zhangsan' password '123456'  设置
hdel key 字段1 字段2  删除多个哈希字段
hexists key 字段 判断是否存在
hkeys key  返回key的所有字段
hlen key  返回key的字段数量
hvals key  返回key的所有值
hgetall key 获取所有字段和值

3.列表。Redis列表只是字符串列表，按插入顺序排序。可以像头部或尾部添加元素。
lindex key index  通过索引从类表中获取元素
linsert key before/after pivot value  在列表中一个元素前或后插入元素
llen key  获取列表的长度
lpop key 删除并获取列表中的第一个元素
lpush key value1 [value2...]  向列表中添加一个或多个值
lrange key start stop 从列表获取一系列元素
lset key index value 通过索引在列表中设置元素的值
rpop  删除并获取最后一个元素

4.集合
Redis集合是唯一字符串的无序集合。唯一值表示集合中不允许键中有重复的数据。
sadd key member1 [member2]  将一个或多个成员添加到集合
scard key  获取集合中的成员数
spop key 从集合中删除并返回随机成员
srandmember key [count] 从集合中获取一个或多个随机成员
srem key member1 [member2] 从集合中删除一个或多个成员

5.有序集合
Redis有序集合和集合一样是string类型元素的集合，且不允许重复的成员。不同的每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。常用于排行榜
zadd key score1 member1 [socre2 member2]  向有序集合添加一个或多个成员，或者更新已有成员分数
zcard key  获取有序集合的成员数
zcount key min max 计算有序集合中指定区间分数的成员数
zincrby key 1 member 有序集合中对指定成员的分数加上1
zrank key member  返回有序集合中指定成员的索引
zrem key member [member]  移除有序集合中的一个或多个成员
zrevrange key start stop [withscores]   返回有序集合指定区间成员，通过索引，从高到低

6.与python交互 
from redis import *
# 创建StrictRedis对象，与redis服务器建立连接
sr = StrictRedis(host='localhost', port=6379, db=0)
# 增
result = sr.set('py1', 'gj')
# 删
result = sr.delete('py1')
# 改
result = sr.set('py1', 'he')
# 查,如果不存在，返回None
result = sr.get('py1')
# 获取键
result = sr.keys()

# Django settings配置缓存为Redis
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'PICKLE_VERSION': -1,
        }
    }
}

# 主从分离
REDIS = {
    'Master':{
        'host': '127.0.0.1',
        'port': 6379,
        'db': 3
    },
    'Slave': {
        'host': '127.0.0.1',
        'port': 6379,
        'db': 3
    }
}
```



### MongoDB

##### 1.概述

```
MongoDB介于关系型数据和非关系型数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，类似json格式。因此可以存储比较复杂的数据类型
MongoDB最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库表单查询的绝大部分功能，还支持对数据建立索引。

适合场景：事件的记录，内容管理或者博客平台等等
数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存储在屋里内存中，从而达到高速读写
json的存储格式
```

##### 

> | MySQL                 | MongoDB     | 解释            |
> | --------------------- | ----------- | --------------- |
> | database              | database    | 数据库          |
> | table                 | collection  | 数据表/集合     |
> | row【一条记录，实体】 | document    | 行/文档         |
> | column                | field       | 列/字段或者属性 |
> | table join            | 不支持      | 表连接          |
> | primary key           | primary key | 主键            |
>
> 解释
>
> 数据库：容器，不管是mysql还是mongodb，一个单一的服务器都可以管理多个数据库
>
> 集合：是一组mongodb的文件，等价于mysql中的table，集合中文档可以有不同的字段，也可以有不同的数据类型
>
> 文档：一组键值对，具有动态模式【不同的数据可以是不同的格式】

##### 2.使用

```
# 创建
db.createCollection('myCollection')
# 显示当期那数据库下的集合列表
show collections
# 如果一个集合不存在，直接向其中插入数据，会自动创建
db.newCollection.insert({'name': 'zhangsan'})
# 删除集合
db.collection_name.drop()  # 删除成功返回true

# 文档操作
db.collection_name.insert(document)
db.mycol.insert({id:101, name:'lisi', age:20},{id:102, name:'wangwu', age:33})
# 查看已插入的文档
db.mycol.find().pretty()
# 其它插入文档方法
db.collection.insert([{},])
db.collection.insertOne(): 插入单个文档
db.collection.insertMany(): 插入多个文档

# 查询
db.collection_name.find()[.pretty()]
findOne()：返回一个文档

# 更新文档
db.collection_name.update({'title': 'MongoDB Guide'}, {$set:{'title':'aaa'}},{multi:true})

# 删除文档
result = collection.remove({'name':'rose'})
delete_one/delete_many
```



