### 基本排序与查找

准备数据

```
import random
ls = random.sample([i for i in range(0,100)])
```

##### 1.冒泡排序

```python
def pop_sort(ls):
	for i in range(len(ls) - 1):
		for j in range(len(ls) - 1 - i):
			if ls[j] > ls[j+1]:
				ls[j], ls[j+1] = ls[j+1], ls[j]
	print(ls)
```

简单理解 ：总是相邻的两个数比较，大数后移，时间复杂度：O(n*n)



##### 2.选择排序

```python
def select_sort(ls):
	for i in range(0, len(ls) - 1):
		for j in range(i, len(ls)):
			if ls[i] > ls[j]:
				ls[i], ls[j] = ls[j], ls[i]
	print(ls)
```

简单理解 ：从第一个数开始选定，将选定的数和后面的所有数比较，有更小的就交换到选定的位置，时间复杂度：O(n*n)



##### 3.快速排序-递归写法

```python
def quick_sort(ls):
	if len(ls) <= 1:
		return ls
    return quick_sort([i for i in ls[1:] if i < ls[0]]) + ls[0:1] + quick_sort([i for i in ls[1:] if i >= ls[0]])
```

简单理解：选取基准值0号位，将列表分割为大于大于基准值的列表和小于基准值的列表，再递归切割，按顺序拼接起来就得到了排序后的列表，退出条件为列表长度小于等于1，时间复杂度：O(nlogn), 极端情况O(n*n),空间复杂度O(1)



##### 4.插入排序

```python
def insert_sort(ls):
    for i in range(1, len(ls)):
        value = ls[i]
        j = 0
        for j in range(i-1, -2, -1):
            if ls[j] > value:
                ls[j+1] = ls[j]
            else:
                break
        ls[j+1] = value
    print(ls)
```

简单理解：每次外层循环选定要插入的数A保存，并初始化一个 j 值用于存储内层循环退出时的位置，内层循环将A前面的数和A的值比较，大于就后移一位，直到，退出内层循环后将 A 的值保存到 j+1位置,时间复杂度：最好 O(n),最坏O(n * n),还是记作O(n*n)



##### 5.折半（二分）查找

折半查找要求数据已排序

```
ls = sorted(ls)
```

```python
def half_search(ls, target):
	left = -1
    right = len(ls) - 1
    while left + 1 != right:
        mid = (left + right) // 2
        if ls[mid] < target:
            left = mid
        else:
            right = mid
    if ls[right] != target or right > len(ls):
        print('目标值不在列表中！')
    else:
        print(f'目标值{target}的下标为: {right}')
```

简单理解：类似于对半折纸，找到列表左下标和列表右下标，中间下标，每次都判断中间值和目标值的差距，调整左右下标和中间下标，直到退出循环，输出结果。

时间复杂度：O(log2n)



##### 6.广度优先遍历（搜索）

```python
from collections import deque

def person_is_seller(name):
    return name[-1] == 'm'

graph = {}
graph['you'] = ['alice', 'bob', 'claire']
graph['bob'] = ['anuj', 'peggy']
graph['alice'] = ['peggy']
graph['claire'] = ['thom', 'jonny']
graph['anuj'] = []
graph['peggy'] = []
graph['thom'] = []
graph['jonny'] = []

def search(name):
    search_queue = deque()
    search_queue += graph[name]
    searched = []
    while search_queue:
        person = search_queue.popleft()
        if person not in searched:
            if person_is_seller(person):
                print(f'{person} is a lemon seller!')
                return True
            else:
                searched.append(person)
               	search_queue += graph[person]
    print('没能找到到目标')
    return False

search('you')
```

简单理解：每当验证一个人后，就将他的邻居加入到队列中，左出右进，直到找到目标或队列消耗完毕。